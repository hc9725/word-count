#include <unistd.h>
#include <sys/stat.h>
#include <getopt.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include "dbllink.h"
#include "getword.h"
#include "getwordstdin.h"
//#include "wordcount.h"
#include "wordinsert.h"
void *myprint(void *data)
{
	STWD *stp =(STWD *)data;
	printf("%-4d ",stp->frq);
	printf("%s\n",stp->word);
};
static Dlinklist list;
int cmpword(const void *a, const void *b);
int cmpfrq(const void *a,const void *b);
void main(int argc, char **argv)
{

	char *pathname;
	FILE *fp;
	static int uptolower = 0;
	list =  initlist();
	int opt;
	int nesecs,tfnd;
	nesecs = 0;
	tfnd = 0;
	int flag = 1;
	int flagul=0;
	while((opt = getopt(argc,argv, "dlfhe")) != -1)
	{
		switch(opt)
		{
			case 'd':
				{
					flag = 1;
				//	sortlist(list, cmpword);
				//	myscan(list, myprint);
				};break;
			case 'l':
				{
					flag = 2;
				//	myscan(list,myprint);
				};break;
			case 'f':
				{
					flag = 3;
				//	sortlist(list, cmpword);
				//	sortlist(list, cmpfrq);
				//	myscan(list, myprint);
				};break;
			case 'e':
				{
					flagul = 1;
				};break;
			case 'h':
			default :
				{
					printf("Usage:\n\t-d dictionary sort\n\t-l  the origonl sort\n\t-f frequence sort\
					\n\t-h help\n\t-c to engore the uper or lower case\n\t with the file path \n");
					exit(1);
				}
		}
	}
	   	 if(flagul == 1)
	               	 uptolower = 1;
		if(optind < argc)
		{
			while(optind < argc)
			{
				pathname = argv[optind++];
				if(access(pathname,0) == -1)
				{
					printf("mwc:%s:没有那个文件或者目录\n",pathname);
					exit(1);
				}
				else if(access(pathname,4) == -1)
				{
					printf("mwc:%s:权限不够\n",pathname);
					exit(1);
				}
				else
				{
					struct stat sb;
					printf("%s\n",pathname);
					stat(pathname,&sb);
					if(S_ISDIR(sb.st_mode))
					{
						printf("mwc:%s/: 是一个目录\n",pathname);	
					//	exit(1);
						//break;
						//continue;

					}
					else
					{
						fp = fopen(pathname,"r");
	                			if(fp == NULL)
						{
							printf("mwc: %s:未知错误发生\n",pathname);
                        				exit(1);
					 	}	
					 	//printf("herehere11 %s\n",pathname);	
         					getword(fp,uptolower,list);
						//wordcount(list);
						switch(flag)
						{
						//	printf("herehere %s\n",pathname);
							case 1:
							{
						//	printf("comehere yet?\n");
						//		int listlen = dlistlength(list);
						//		printf("%d\n",listlen);
								sortlist(list,cmpword);
								myscan(list,myprint);
							};break;
							case 2:
							{
								myscan(list,myprint);
							};break;
							case 3:
							{
								sortlist(list,cmpword);
								sortlist(list,cmpfrq);
								myscan(list,myprint);
							};break;
							default:
							{
								printf("error\n");
								exit(0);
							};break;
						}
						dclearlist(list);
					}
				}
			}
		}
		else
		{
			getwordstdin(uptolower,list);
			printf("\n");
			//wordcount(list);
			switch(flag)
			{
				case 1:
				{

					sortlist(list,cmpword);
					myscan(list,myprint);
					};break;
				case 2:
				{
					myscan(list,myprint);
					};break;
				case 3:
				{
					sortlist(list,cmpword);
					sortlist(list,cmpfrq);
					myscan(list,myprint);
				};break;
				default:
				{
					printf("error\n");
					exit(0);
				};break;
			}
		}
}


int cmpword(const void *a, const void *b)
{
	STWD *p1 = (STWD *)a;
	STWD *p2 = (STWD *)b;
	return  strcmp((const char *)p1->word, (const char *)p2->word);
//	printf("%d",i);
//	return i;
}



int cmpfrq(const void *a,const void *b)
{
	int a1 = *(int *)a;
	int b1 = *(int *)b;
	if((a1 - b1) > 0)
		return 1;
	else if(a1 == b1)
		return 0;
	else return -1;
}
